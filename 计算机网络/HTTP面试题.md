# 在浏览器中输入url地址显示主页的过程

- DNS解析
  
  - 域名到ip的映射
  - 根域名 顶级域名 权威DNS服务器

- TCP连接

- 发送HTTP请求

- 服务器处理请求并返回HTTP报文

- 浏览器解析渲染页面

- 连接结束
  
  # QPS和TPS的区别

- TPS：Transactions Per Second（每秒传输的事物处理个数），即服务器每秒处理的事务数

- QPS：Queries Per Second意思是“每秒查询率”，是一台服务器每秒能够相应的查询次数，是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准
  
  # 有哪些编码格式(GBK,UTF-8,ISO-)有没有想过为什么会有这么多的编码格式

- 常见的编码格式
  
  - ASCII码
    - 它能表示128个字符，其中包括英文字符、阿拉伯数字、西文字符以及32个控制字符
  - 扩展的ASCII码
    - 原基础上增加
  - Unicode符号集
    - 很多人都说Unicode编码，但其实Unicode是一个符号集（世界上所有符号的符号集
  - UTF-8
    - UTF-8就是在互联网上使用最广的一种unicode的实现方式
    - 它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。
  - GBK/GB2312/GB18030
    - GBK和GB2312都是针对简体字的编码，只是GB2312只支持六千多个汉字的编码，而GBK支持1万多个汉字编码。而GB18030是用于繁体字的编码。汉字存储时都使用两个字节来储存。

- 因为指定的标准的人不同，应用的场景不同，有时候这个时间满足了，但是未来不满足就得新增，这个地区的满足了，但是另外的地区不满足
  
  # 实现一个长URL转短URL

- 利用放号器，初始值为0，对于每一个短链接生成请求，都递增放号器的值，再将此值转换为62进制（a-zA-Z0-9），比如第一次请求时放号器的值为0，对应62进制为a，第二次请求时放号器的值为1，对应62进制为b，第10001次请求时放号器的值为10000，对应62进制为sBc

- 将短链接服务器域名与放号器的62进制值进行字符串连接，即为短链接的URL，比如：t.cn/sBc。

- 重定向过程：生成短链接之后，需要存储短链接到长链接的映射关系，即sBc -> URL，浏览器访问短链接服务器时，根据URL Path取到原始的链接，然后进行302重定向。映射关系可使用K-V存储，比如Redis或Memcache
  
  - 一长对多短，设定上限max，达到后可以用缓存存关系用LRU淘汰最近未被使用的

# OSI 7层协议，路由器工作在哪一层，交换机工作在哪一层

OSI7层协议包括：应用层、表示层、会话层、传输层、网络层、数据链路层和物理层。

路由器通常工作在网络层，也就是第3层，用于实现不同网络之间的通信和数据转发，通过寻址和路由选择等技术来实现数据包的转发和传输。路由器主要作用是对不同网络之间的数据进行转发和路由选择，以实现网络之间的通信。

交换机通常工作在数据链路层，也就是第2层，用于实现局域网内部的数据交换和转发。交换机通过学习MAC地址来建立一个端口和MAC地址的映射表，实现对数据包的快速转发和过滤，避免广播风暴和网络拥塞。交换机主要作用是对同一个局域网内的数据进行快速转发和过滤，以实现局域网内部的通信。

# NAT是干嘛的，为什么需要转换

NAT（Network Address Translation，网络地址转换）是一种网络地址转换技术，通常用于将内部网络的私有IP地址转换为公共IP地址，以实现对外访问。

NAT的主要作用是解决IPv4地址短缺问题，使得内部网络中的多个设备可以通过一个公共IP地址访问互联网。在一个企业或家庭网络中，往往会有多台设备共享一个公共IP地址，这些设备都使用内部网络的私有IP地址。当这些设备需要访问互联网时，NAT会将它们的IP地址转换为公共IP地址，并在内部网络和互联网之间进行转发和路由。

NAT需要进行地址转换，主要是因为IPv4地址资源有限，无法为所有的设备都分配公共IP地址，而私有IP地址则可以在内部网络中自由使用。此外，NAT还可以提高网络的安全性，因为公共IP地址只有在经过NAT的转换后才能被内部网络访问，而互联网上的其他设备无法直接访问内部网络。

# 子网掩码是干嘛用的

子网掩码（subnet mask）是一种用于指定IP地址的网络地址部分和主机地址部分的掩码，通常与IP地址一起使用，用于划分网络和主机。

IP地址由32位二进制数组成，通常使用点分十进制表示法，例如192.168.0.1。其中，前24位用于指定网络地址，后8位用于指定主机地址。子网掩码也是一个32位的二进制数，用于指示网络地址和主机地址的范围。

通过子网掩码，可以将IP地址划分为不同的子网。例如，使用子网掩码255.255.255.0可以将IP地址192.168.0.1划分为网络地址192.168.0.0和主机地址1，同时也可以将IP地址192.168.0.2划分为相同的网络地址192.168.0.0和主机地址2，这样就可以将这两个IP地址划分为同一个子网中。

子网掩码的主要作用是实现IP地址的划分和分类，使得网络管理更加灵活和高效。通过合理地划分IP地址，可以减少网络广播和冲突，提高网络的性能和可靠性。同时，子网掩码还可以用于实现网络安全控制，例如通过ACL（Access Control List）实现对不同子网的访问控制。

# tcp整个流程，closed_wait状态?

## 建立连接的过程？（三次握手）

TCP三次握手是TCP协议中建立连接的重要过程，它涉及客户端和服务器的状态变化以及发送请求的具体内容。

一开始，客户端和服务端都处于CLOSE状态。当服务端准备好接受连接时，它会进入LISTEN状态，等待客户端的连接请求。

第一次握手时，客户端会初始化一个随机序号，并发送一个SYN请求连接报文给服务端，这个报文中包含了客户端的初始序列号。此时，客户端的状态变为SYN-SENT，等待服务端的确认。

服务端收到SYN请求后，会进行第二次握手。服务端也会随机初始化一个序号，并将客户端的序列号加1作为确认应答报文ACK，同时发送自己的SYN报文。这样，服务端发送的就是一个SYN+ACK的报文，此时服务端的状态变为SYN-RCVD。

客户端收到服务端的SYN+ACK报文后，会进行第三次握手。客户端会再次发送一个ACK报文给服务端，确认服务端的SYN报文，并将服务端的ACK序列号加1。此时，客户端的状态变为ESTABLISHED，表示连接已建立。服务端收到客户端的ACK报文后，状态也变为ESTABLISHED。

这个三次握手的过程确保了客户端和服务端都能准确地知道对方已准备好进行数据传输，是TCP协议中保证数据可靠传输的重要机制。

## 断开连接过程？（四次挥手）

首先，我们要明确TCP连接是全双工的，这意味着数据可以在两个方向上同时传输。因此，当一方想要关闭连接时，它需要通知另一方，并确保双方的数据传输都已完成，然后才能完全关闭连接。这就是四次挥手的主要目的。

第一次挥手是由客户端发起的。当客户端没有更多的数据要发送时，它会发送一个FIN报文段给服务端。这个FIN报文段的作用是告诉服务端：“我已经没有数据要发送了，你可以开始关闭你那边到我这边的连接了”。同时，客户端会进入FIN_WAIT_1状态，等待服务端的确认。

第二次挥手发生在服务端收到FIN报文段后。服务端会发送一个ACK报文段给客户端，作为对FIN报文段的确认。这个ACK报文段的作用是告诉客户端：“我已经收到你的关闭请求了，我这边会准备关闭连接，但是在我发送完所有的数据之前，连接还不会完全关闭”。此时，服务端进入`CLOSE_WAIT`状态，等待所有数据发送完毕。而客户端在收到ACK后，会进入FIN_WAIT_2状态，等待服务端的FIN报文段。

第三次挥手发生在服务端发送完所有数据后。此时，服务端会发送一个FIN报文段给客户端，告知客户端它也没有数据要发送了，可以关闭连接了。这个FIN报文段的作用是告诉客户端：“我这边也没有数据要发送了，我们可以关闭连接了”。服务端在发送FIN报文段后，会进入LAST_ACK状态，等待客户端的确认。

第四次挥手是客户端在收到服务端的FIN报文段后发起的。客户端会发送一个ACK报文段给服务端，作为对FIN报文段的确认。这个ACK报文段的作用是告诉服务端：“我已经收到你的关闭请求了，我会关闭连接”。在发送完ACK报文段后，客户端会进入TIME_WAIT状态。这个状态会持续一段时间（通常是2MSL，即数据包在网络中的最大生存时间），以确保关闭请求和确认报文段能够被对方正确接收。如果在这段时间内没有收到对方的重新发送请求，那么客户端会最终关闭连接，进入CLOSED状态。而服务端在收到ACK报文段后，会立即关闭连接，进入CLOSED状态。

这就是TCP四次挥手的全过程。通过这个过程，TCP连接能够在确保双方数据传输完成的前提下安全地关闭。这个过程的每一步都是必要的，以确保数据的完整性和可靠性。

# http协议报文格式

首先，HTTP请求报文主要由请求行、请求头部和请求体三个部分构成。请求行包含了请求的方法，比如GET或POST，请求的URL路径，以及HTTP协议的版本。紧接着请求行的是请求头部，它由多个键值对组成，每个键值对代表一种信息或设置，比如Host字段标明请求的目标主机，User-Agent字段描述发出请求的用户代理信息，Accept字段则列出客户端能够理解的内容类型。请求头部之后，可能跟随一个请求体，它通常用于POST或PUT请求中，包含客户端提交给服务器的数据。

其次，HTTP响应报文的结构与请求报文相似，由状态行、响应头部和响应体组成。状态行包含HTTP协议版本、状态码以及状态描述信息。比如，状态码200表示请求成功，404则表示资源未找到。响应头部也包含多个键值对，提供有关响应的附加信息，如Content-Type描述响应体的内容类型，Content-Length指明响应体的长度。响应体则包含服务器返回给客户端的实际数据内容，如HTML文件、图片或其他媒体资源。

# websocket升级流程

WebSocket连接建立的过程：

1. 客户端发起连接请求

首先，客户端（如Web浏览器）会向服务器发起一个HTTP请求，意在建立一个WebSocket连接。这个HTTP请求不同于常规的请求，因为它包含了特殊的头信息，用以表明客户端希望将连接从HTTP升级到WebSocket。

2. 包含特殊的头信息

在HTTP请求头中，必须包含以下关键信息：

- `Upgrade: websocket`：这个头部告诉服务器，客户端希望将连接升级到WebSocket协议。
- `Connection: Upgrade`：此头部表示客户端要求服务器升级当前的HTTP连接到WebSocket连接。
- `Sec-WebSocket-Key`：一个由客户端随机生成的密钥，用于服务器在响应中生成对应的`Sec-WebSocket-Accept`值，以证明它理解了WebSocket协议。
- `Sec-WebSocket-Version`：支持的WebSocket协议版本，通常是13。

可能还包括其他一些可选的头信息，如子协议、扩展等。

3. 服务器响应并升级连接

服务器在接收到这个特殊的HTTP请求后，会检查请求头中的信息，确认是否支持并愿意进行连接升级。如果一切正常，服务器会返回一个HTTP响应，状态码为`101 Switching Protocols`，表示服务器同意将连接从HTTP升级到WebSocket。

服务器的响应中会包含以下头部信息：

- `Upgrade: websocket`：确认连接已经升级到WebSocket。

- `Connection: Upgrade`：表示连接已被升级。

- `Sec-WebSocket-Accept`：根据客户端提供的`Sec-WebSocket-Key`计算得出的值，用于验证服务器的响应。
4. 完成握手并建立WebSocket连接

当客户端接收到服务器的`101 Switching Protocols`响应后，WebSocket握手过程就完成了。此时，连接已经从HTTP连接正式升级为WebSocket连接。

5. 进行数据传输

一旦WebSocket连接建立成功，客户端和服务器就可以通过这个连接进行双向的、全双工的数据传输了。这意味着客户端和服务器可以同时发送和接收消息。

6. 关闭WebSocket连接

当数据传输完成或者任何一方决定关闭连接时，会发送一个WebSocket关闭帧来通知对方关闭连接。这样，WebSocket连接就会被优雅地关闭。

总的来说，WebSocket连接的建立过程是一个从HTTP协议升级到WebSocket协议的过程，它允许客户端和服务器之间进行实时、双向的通信。

# http1.0，http1.1，http2以及http3的发展以及变化

HTTP（超文本传输协议）是 Web 上数据传输的基础协议。随着网络技术的发展，HTTP 协议也经历了多个版本的迭代，每个版本在性能、安全性和功能上都有不同的改进。以下是 HTTP 1.0、HTTP 1.1、HTTP 2 和 HTTP 3 的发展及其变化概述：

### 1. HTTP/1.0

#### 发展背景
- **发布**：1996年
- **主要特点**：HTTP/1.0 是第一个广泛使用的 HTTP 版本，它为 Web 的早期发展奠定了基础。

#### 关键特性
- **请求-响应模型**：HTTP/1.0 使用简单的请求-响应模型。每个请求都需要一个独立的响应。
- **无连接**：每个请求和响应都是独立的。服务器处理请求后，关闭连接，这意味着每次请求都需要重新建立连接。
- **状态码**：引入了状态码的概念，用于表示请求的结果状态，如 200（OK）、404（Not Found）。
- **内容类型**：支持 `Content-Type` 头，用于标识请求或响应的内容类型。

#### 局限性
- **性能瓶颈**：每个请求需要建立新的连接，造成了较大的延迟和额外的开销。

### 2. HTTP/1.1

#### 发展背景
- **发布**：1999年
- **主要特点**：HTTP/1.1 在 HTTP/1.0 的基础上做出了许多改进，以提高性能和功能。

#### 关键特性
- **持久连接**：引入了持久连接（Keep-Alive）机制，允许在一个连接上发送多个请求和响应，减少了连接建立的开销。
- **管道化**：允许在一个连接上并行发送多个请求，但响应必须按照请求顺序返回（后续的请求必须等待前面的请求完成）。
- **分块传输编码**：支持分块传输编码（Chunked Transfer Encoding），允许动态生成响应内容而不需要事先知道内容的长度。
- **缓存控制**：引入了更多的缓存相关头部，如 `Cache-Control`，提供了更精细的缓存控制机制。
- **增强的请求头**：支持更丰富的请求头和响应头，如 `Host` 头（允许多个虚拟主机共享同一个 IP 地址）。

#### 局限性
- **阻塞问题**：管道化虽然减少了连接数量，但仍然存在头部阻塞问题，即一个长时间的响应会阻塞后续请求的响应。

### 3. HTTP/2

#### 发展背景
- **发布**：2015年
- **主要特点**：HTTP/2 是对 HTTP/1.x 的重大改进，旨在提高 Web 性能和效率。

#### 关键特性
- **二进制协议**：HTTP/2 使用二进制格式而不是文本格式，这使得协议解析更高效。
- **多路复用**：允许在一个连接上并行处理多个请求和响应，解决了 HTTP/1.x 的头部阻塞问题。每个请求和响应可以被分解成多个帧（Frame）进行传输。
- **头部压缩**：使用 HPACK 算法对 HTTP 头部进行压缩，减少了冗余数据的传输量。
- **流量控制**：支持流量控制和优先级，允许客户端和服务器更好地管理数据流量和优先级。
- **服务器推送**：服务器可以主动推送资源到客户端，减少了客户端请求的延迟。

#### 局限性
- **复杂性**：尽管 HTTP/2 改进了许多性能问题，但其协议本身的复杂性增加了客户端和服务器的实现复杂度。

### 4. HTTP/3

#### 发展背景
- **发布**：HTTP/3 的规范在 2021 年成为 RFC 9114，它基于 QUIC 协议（Quick UDP Internet Connections）。
- **主要特点**：HTTP/3 旨在进一步提升性能，特别是在延迟和连接恢复方面。

#### 关键特性
- **基于 QUIC**：HTTP/3 使用 QUIC 协议，它是基于 UDP 的传输协议，相较于 TCP 更加高效和灵活。QUIC 提供了内置的加密、连接迁移和更低的连接建立延迟。
- **零轮次握手**：QUIC 协议支持零轮次握手（0-RTT），使得在重复连接时可以更快速地恢复之前的会话。
- **多路复用**：类似于 HTTP/2，HTTP/3 支持多路复用，但由于 QUIC 的内建机制，避免了 HTTP/2 的阻塞问题。
- **改进的错误恢复**：QUIC 提供了更好的错误恢复和丢包恢复机制，减少了网络抖动对性能的影响。
- **内置加密**：QUIC 协议内置了加密机制，所有 HTTP/3 流量都经过加密，提高了安全性。

#### 局限性
- **网络兼容性**：由于 HTTP/3 使用 UDP，因此需要网络设备和中间件支持 UDP，以确保兼容性。
- **推广普及**：虽然 HTTP/3 提供了显著的性能改进，但它的推广和普及仍在进行中，需要时间来广泛部署。

### 总结

- **HTTP/1.0**：提供了基本的请求-响应模型，适用于早期 Web 的需求，但性能有限。
- **HTTP/1.1**：引入了持久连接、管道化和缓存控制等特性，显著提升了性能，但仍存在阻塞问题。
- **HTTP/2**：通过二进制协议、多路复用、头部压缩等机制，显著提高了性能和效率，但协议复杂度增加。
- **HTTP/3**：基于 QUIC 协议，进一步改进了连接延迟、错误恢复和内置加密，提供了更高的性能和安全性，但在网络兼容性和普及方面仍在发展中。

每个版本的 HTTP 协议都在前一个版本的基础上进行了改进，以适应不断变化的 Web 需求和技术环境。
