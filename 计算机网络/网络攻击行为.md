# [CSRF攻击](#)
## [什么是CSRF攻击](#)
CSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的
## [场景](#)
一个典型的CSRF攻击有着如下的流程：
- 受害者登录a.com，并保留了登录凭证（Cookie）。
- 攻击者引诱受害者访问了b.com。
- b.com 向 a.com 发送了一个请求：a.com/act=xx。浏览器会默认携带a.com的Cookie。
- a.com接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求。
- a.com以受害者的名义执行了act=xx。
攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让a.com执行了自己定义的操作。
## [怎么预防](#)
### [阻止不明外域的访问](#)
- 在HTTP协议中，每一个异步请求都会携带两个Header，用于标记来源域名：
  - Origin Header
    - 使用Origin Header确定来源域名
  - Referer Header
- 这两个Header在浏览器发起请求时，大多数情况会自动带上，并且不能由前端自定义内容。 服务器可以通过解析这两个Header中的域名，确定请求的来源域。
### [提交时要求附加本域才能获取的信息](#)
- [CSRF Token](#)
  - 将CSRF Token输出到页面中
  - 页面提交的请求携带这个Token
  - 服务器验证Token是否正确
- [双重Cookie验证](#)
  - 在用户访问网站页面时，向请求域名注入一个Cookie，内容为随机字符串（例如csrfcookie=v8g9e4ksfhw）。
  - 在前端向后端发起请求时，取出Cookie，并添加到URL的参数中（接上例POST https://www.a.com/comment?csrfcookie=v8g9e4ksfhw）。
  - 后端接口验证Cookie中的字段与URL参数中的字段是否一致，不一致则拒绝。
- [Samesite Cookie属性](#)
  - Samesite 有两个属性值，分别是 Strict 和 Lax
    - Samesite=Strict
      - 这种称为严格模式，表明这个 Cookie 在任何情况下都不可能作为第三方 Cookie
    - Samesite=Lax
      - 这种称为宽松模式，比 Strict 放宽了点限制：假如这个请求是这种请求（改变了当前页面或者打开了新页面）且同时是个GET请求，则这个Cookie可以作为第三方Cookie
  - 不成熟

# [XSS](#)
## [什么是XSS](#)
XSS是一种常见的web安全漏洞，它允许攻击者将恶意代码植入到提供给其它用户使用的页面中
## [分类](#)
- [存储型XSS](#)
  - 主要出现在让用户输入数据，供其他浏览此页的用户进行查看的地方，包括留言、评论、博客日志和各类表单等。应用程序从数据库中查询数据，在页面中显示出来，攻击者在相关页面输入恶意的脚本数据后，用户浏览此类页面时就可能受到攻击。这个流程简单可以描述为：恶意用户的Html输入Web程序->进入数据库->Web程序->用户浏览器
  - 比如说我写了一个网站，然后攻击者在上面发布了一个文章，内容是这样的 `<script>alert(document.cookie)</script>`,如果我没有对他的内容进行处理，直接存储到数据库，那么下一次当其他用户访问他的这篇文章的时候，服务器从数据库读取后然后响应给客户端，浏览器执行了这段脚本，就会将cookie展现出来，这就是典型的存储型XSS
- [反射型XSS](#)
  - 反射型XSS，主要做法是将脚本代码加入URL地址的请求参数里，请求参数进入程序后在页面直接输出，用户点击类似的恶意链接就可能受到攻击。
## [如何预防XSS](#)
答案很简单，坚决不要相信用户的任何输入，并过滤掉输入中的所有特殊字符。这样就能消灭绝大部分的XSS攻击。
- [过滤特殊字符](#)
  - 避免XSS的方法之一主要是将用户所提供的内容进行过滤(如上面的script标签)。
- [使用HTTP头指定类型](#)
  - `w.Header().Set("Content-Type","text/javascript")`
  - 这样就可以让浏览器解析javascript代码，而不会是html输出。

# [SQL注入](#)
## [什么是SQL注入](#)
- 击者成功的向服务器提交恶意的SQL查询代码，程序在接收后错误的将攻击者的输入作为查询语句的一部分执行，导致原始的查询逻辑被改变，额外的执行了攻击者精心构造的恶意代码
- 这是最常见的 SQL注入攻击，当我们输如用户名 admin ，然后密码输如`' OR '1'=1='1`的时候，我们在查询用户名和密码是否正确的时候，本来要执行的是`SELECT * FROM user WHERE username='' and password=''`,经过参数拼接后，会执行 SQL语句 SELECT * FROM user WHERE username='' and password='' OR '1'='1'，这个时候1=1是成立，自然就跳过验证了。
- 但是如果再严重一点，密码输如的是`';DROP TABLE user;--`，那么 SQL命令为`SELECT * FROM user WHERE username='admin' and password='';drop table user;--'` 这个时候我们就直接把这个表给删除了。
## [怎么预防](#)
- 在Java中，我们可以使用预编译语句(PreparedStatement)，这样的话即使我们使用 SQL语句伪造成参数，到了服务端的时候，这个伪造 SQL语句的参数也只是简单的字符，并不能起到攻击的作用。
- 在应用发布之前建议使用专业的SQL注入检测工具进行检测，以及时修补被发现的SQL注入漏洞。网上有很多这方面的开源工具，例如sqlmap、SQLninja等。
- 避免网站打印出SQL错误信息，比如类型错误、字段不匹配等，把代码里的SQL语句暴露出来，以防止攻击者利用这些错误信息进行SQL注入。


# [DDOS](#)
## [什么是DDOS](#)
分布式拒绝服务攻击（Distributed Denial of Service），简单说就是发送大量请求是使服务器瘫痪
- [TCP的SYN攻击](#)
  - 在三次握手过程中，服务器发送 SYN-ACK 之后，收到客户端的 ACK 之前的 TCP 连接称为半连接(half-open connect)。此时服务器处于 SYN_RCVD 状态。当收到 ACK 后，服务器才能转入 ESTABLISHED状态.
  - SYN攻击指的是，攻击客户端在短时间内伪造大量不存在的IP地址，向服务器不断地发送SYN包，服务器回复确认包，并等待客户的确认。由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的SYN包将长时间占用未连接队列，正常的SYN请求被丢弃，导致目标系统运行缓慢，严重者会引起网络堵塞甚至系统瘫痪。
## [怎么预防](#)
- [分析可疑流量过滤](#)
  - 关键在于区分攻击流量与正常流量
- [速率限制](#)
- [将攻击流量分散至分布式服务器网络，直到网络吸收流量为止](#)




  