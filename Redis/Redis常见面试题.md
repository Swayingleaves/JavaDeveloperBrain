## 储存结构和使用场景
- `string` 字符串、数字，一些简单的k-v数据
- `list` 数组、集合，简单消息队列（缺点很多，比如不能重复消费，不能多订阅，无"消息持久化"，无确认机制）
- `hash` 储存对象
- `set` 不可重复数据、做交并集的数据
- `zset` 排序的不可重复数据，比如 一个直播间的礼物排行榜

## 淘汰策略
1. `noeviction`：当内存不足以容纳新写入数据时，新写入操作会报错。
2. `allkeys-lru`：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。
3. `allkeys-random`：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。
4. `volatile-lru`：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。
5. `volatile-random`：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。
6. `volatile-ttl`：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。

## AOF文件很大怎么办
执行 BGREWRITEAOF 命令，对AOF文件重写

## 为什么Redis使用跳表，不使用红黑树或B+树

Redis 使用跳表的原因

Redis 在实现有序集合（ZSet）时，使用的是跳表（SkipList），而没有选择红黑树或 B+ 树。

### 2.1 跳表的优点

- 实现简单：跳表的结构相对简单，使用多级索引进行加速。虽然在理想情况下，它的时间复杂度和红黑树相同，都是 O(log n)，但跳表的实现代码简单且直观，插入和删除也较为轻量级。
- 支持区间查询：Redis 使用的跳表结构特别适合范围查询，跳表允许快速的从某个节点开始进行逐步遍历，非常适合 Redis 中经常需要的范围查询操作（如查找某个分数范围内的所有元素）。
- 顺序性：跳表天然是有序的，Redis 的有序集合要求能够对元素按照分数进行排序并保持有序，这一要求跳表可以很好地满足。
### 2.2 为什么不使用红黑树？
- 红黑树的复杂性：红黑树的实现虽然也能保证 O(log n) 的时间复杂度，但插入、删除和调整平衡的逻辑相对复杂，特别是在 Redis 这种高性能、实时要求的系统中，代码简洁和可维护性很重要。跳表在处理区间查询时的遍历逻辑比红黑树更直观。
- 区间操作性能：红黑树虽然可以通过中序遍历实现区间查询，但性能和跳表相比，略显不足。跳表从某个节点可以直接开始线性扫描，而红黑树需要从根节点逐步找到起始点，跳表在这方面有天然优势。
### 2.3 为什么不选择 B+ 树？
- B+ 树适合磁盘存储：和 HashMap 类似，B+ 树在内存中的查找效率并不如跳表。B+ 树的节点结构复杂，维护成本高，且 Redis 是基于内存的数据库系统，不需要像 B+ 树那样通过层次结构优化磁盘 I/O。
- Redis 的简单高效设计理念：Redis 追求的是极简和高效，而跳表比 B+ 树的实现简单，操作也更加高效。

总结：

- Redis 选择跳表：跳表的实现简单，支持快速区间查询，非常适合 Redis 中有序集合的场景需求。相比红黑树，跳表在遍历和范围查询中表现更优，而相比 B+ 树，跳表的内存使用更加轻量级，更加适合 Redis 的内存结构。
