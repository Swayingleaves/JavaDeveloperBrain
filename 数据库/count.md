
* [分页count(*)的优化](#分页count的优化)
    * [场景](#场景)
    * [count(*)的工作原理](#count的工作原理)
    * [解决方案](#解决方案)
        * [show table status](#show-table-status)
        * [缓存总数](#缓存总数)
            * [redis缓存](#redis缓存)
            * [数据库单独表来记录总数](#数据库单独表来记录总数)
        * [做上/下一页](#做上下一页)
        * [es统计](#es统计)
* [总结](#总结)

# 分页count(*)的优化
## 场景
现在有单表数量在千万级别，前端需要做分页展示，分页需要返回表总数，页总数等等，这里涉及到用count(*)统计全表数量

但是这个过程总是很慢，耗时一般在4-5s以上
## count(*)的工作原理
在不同的MySQL引擎中，count(*)有不同的实现方式。

- MyISAM引擎把一个表的总行数存在了磁盘上，因此执行count(*)的时候会直接返回这个数，效率很高；
- InnoDB引擎执行count(*)的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数，所以比较麻烦。

虽然针对没有where条件的SQL，MySQL是有优化的，优化器会选择成本最小的辅助索引查询计数，但是有时候预估的成本会大于全表扫描

而innodb为什么不也存一个总行数呢，由于多版本并发控制（MVCC）的原因，InnoDB表“应该返回多少行”也是不确定的

## 解决方案
### show table status
如果你用过show table status 命令的话，就会发现这个命令的输出结果里面也有一个TABLE_ROWS用于显示这个表当前有多少行，这个命令执行挺快的，那这个TABLE_ROWS能代替count(*)吗？
```sql
-- mysql
show table status where Name = 'xxx';
-- pgsql
show tables;
```
其实这个索引统计的值是通过采样来估算的。实际上，TABLE_ROWS就是从这个采样估算得来的，因此它也很不准。有多不准呢，官方文档说误差可能达到40%到50%。所以，show table status命令显示的行数也不能直接使用。

优点：
- 快

缺点：
- 估计的总数，并非精确
### 缓存总数
#### redis缓存
这种方案，可以将总数统计放在Redis缓存中，每次新增、删除需要同步结果到Redis和数据库，之后查询总数直接查询Redis

优点：
- 快

缺点：
- 缓存和数据的一致性问题
#### 数据库单独表来记录总数
可以使用触发器，在数据库表insert、delete时将数据更新到一个专门记录数量的表中

优点：
- 快

缺点：
- 使用触发器可能会影响插入删除性能
### 做上/下一页
要求前端不分页，用户只能通过上一页，下一页来查询数据，后端通过表主键id来做查询
```sql
select xx from table where id > #{lastId} and xxx = yyy limit 1 offset 1000
```
这里要求主键ID最好是自增的数字类型
### es统计
数据全保存在es，后续直接所有操作直接操作es即可

优点：
- 快

缺点：
- es和关系型数据库的区别，且大部分场景es也不适用

# 总结
综上，我的方案选择优先级
1. 不做分页，做上下页滚动
2. 返回大概总数，不需要精确
3. 数据库单独表来存总数
4. Redis
5. 直接count(*)，可能会超时
6. es
