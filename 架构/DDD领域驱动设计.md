# DDD（Domain Driven Design）领域驱动设计

DDD是一种设计思想，在设计架构时的让我们可以选择的方式、思路、思考的方向+1，而并不是让所有的架构都是DDD，适合的才是最好的；

## 软件架构模式的演进

在进入今天的主题之前，我们先来了解下背景。

我们知道，这些年来随着设备和新技术的发展，软件的架构模式发生了很大的变化。软件架构模式大体来说经历了从单机、集中式到分布式微服务架构三个阶段的演进
。随着分布式技术的快速兴起，我们已经进入到了微服务架构时代。

![软件架构模式的演进.png](..%2Fimg%2F%E6%9E%B6%E6%9E%84%2FDDD%2F%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%BC%94%E8%BF%9B.png)

我们先来分析一下软件架构模式演进的三个阶段。

- 第一阶段是单机架构： 采用面向过程的设计方法，系统包括客户端 UI 层和数据库两层，采用 C/S
  架构模式，整个系统围绕数据库驱动设计和开发，并且总是从设计数据库和字段开始。
- 第二阶段是集中式架构： 采用面向对象的设计方法，系统包括业务接入层、业务逻辑层和数据库层，采用经典的三层架构，也有部分应用采用传统的
  SOA 架构。这种架构容易使系统变得臃肿，可扩展性和弹性伸缩性差。
- 第三阶段是分布式微服务架构：
  随着微服务架构理念的提出，集中式架构正向分布式微服务架构演进。微服务架构可以很好地实现应用之间的解耦，解决单体应用扩展性和弹性伸缩能力不足的问题 。

我们知道，在单机和集中式架构时代，系统分析、设计和开发往往是独立、分阶段割裂进行的。

比如，在系统建设过程中，我们经常会看到这样的情形：A 负责提出需求，B 负责需求分析，C 负责系统设计，D
负责代码实现，这样的流程很长，经手的人也很多，很容易导致信息丢失
。最后，就很容易导致需求、设计与代码实现的不一致，往往到了软件上线后，我们才发现很多功能并不是自己想要的，或者做出来的功能跟自己提出的需求偏差太大。

而且在单机和集中式架构这两种模式下，软件无法快速响应需求和业务的迅速变化 ，最终错失发展良机。此时，分布式微服务的出现就有点恰逢其时的意思了。

## 微服务设计和拆分的困境

那进入微服务架构时代以后，微服务确实也解决了原来采用集中式架构的单体应用的很多问题，比如扩展性、弹性伸缩能力、小规模团队的敏捷开发等等。

但在看到这些好处的同时，微服务实践过程中也产生了不少的争论和疑惑：微服务的粒度应该多大呀？微服务到底应该如何拆分和设计呢？微服务的边界应该在哪里？

可以说，很久以来都没有一套系统的理论和方法可以指导微服务的拆分，包括微服务架构模式的提出者 Martin Fowler
在提出微服务架构的时候，也没有告诉我们究竟应该如何拆分微服务。

于是，在这段较长的时间里，就有不少人对微服务的理解产生了一些曲解。有人认为：微服务很简单，不过就是把原来一个单体包拆分为多个部署包，或者将原来的单体应用架构替换为一套支持微服务架构的技术框架，就算是微服务了。
还有人说：微服务嘛，就是要微要小，拆得越小效果越好。

但我想，这两年，你在技术圈中一定听说过一些项目因为前期微服务拆分过度，导致项目复杂度过高，无法上线和运维。

综合来看，我认为微服务拆分困境产生的根本原因就是 不知道业务或者微服务的边界到底在什么地方 。换句话说，确定了业务边界和应用边界，这个困境也就迎刃而解了。

那如何确定，是否有相关理论或知识体系支持呢？在回答这些问题之前，我们先来了解一下领域驱动设计与微服务的前世今生。

2004 年埃里克·埃文斯（Eric Evans）发表了《领域驱动设计》（Domain-Driven Design –Tackling Complexity in the Heart of
Software）这本书，从此领域驱动设计（Domain Driven Design，简称 DDD）诞生。DDD
核心思想是通过领域驱动设计方法定义领域模型，从而确定业务和应用边界，保证业务模型与代码模型的一致性。

但 DDD 提出后在软件开发领域一直都是雷声大，雨点小！直到 Martin Fowler 提出微服务架构，DDD 才真正迎来了自己的时代。

有些熟悉 DDD 设计方法的软件工程师在进行微服务设计时，发现可以利用 DDD 设计方法来建立领域模型，划分领域边界，再根据这些领域边界从业务视角来划分微服务边界。而按照
DDD 方法设计出的微服务的业务和应用边界都非常合理，可以很好地实现微服务内部和外部的「高内聚、低耦合」。于是越来越多的人开始把
DDD 作为微服务设计的指导思想。

现在，很多大型互联网企业已经将 DDD 设计方法作为微服务的主流设计方法了。DDD 也从过去雷声大，雨点小，开始真正火爆起来。

## 为什么 DDD 适合微服务？

众里寻他千百度。蓦然回首，那人却在灯火阑珊处。在经历了多年的迷茫和争论后，微服务终于寻到了他的心上人。

那 DDD 到底是何方神圣，拥有什么神器呢？

DDD 是一种处理高度复杂领域的设计思想 ，它试图分离技术实现的复杂性，并围绕业务概念构建领域模型来控制业务的复杂性，以解决软件难以理解，难以演进的问题。DDD
不是架构，而是一种架构设计方法论 ，它通过边界划分将复杂业务领域简单化，帮我们设计出清晰的领域和应用边界，可以很容易地实现架构演进。

DDD 包括战略设计和战术设计两部分。

- 战略设计主要从业务视角出发 ，建立业务领域模型，划分领域边界，建立通用语言的限界上下文，限界上下文可以作为微服务设计的参考边界。
- 战术设计则从技术视角出发 ，侧重于领域模型的技术实现，完成软件开发和落地，包括：聚合根、实体、值对象、领域服务、应用服务和资源库等代码逻辑的设计和实现。

我们不妨来看看 DDD 是如何进行战略设计的。

DDD 战略设计会 建立领域模型 ，领域模型可以用于指导微服务的设计和拆分
。事件风暴是建立领域模型的主要方法，它是一个从发散到收敛的过程。它通常采用用例分析、场景分析和用户旅程分析，尽可能全面不遗漏地分解业务领域，并梳理领域对象之间的关系，这是一个发散的过程。事件风暴过程会产生很多的实体、命令、事件等领域对象，我们将这些领域对象从不同的维度进行聚类，形成如聚合、限界上下文等边界，建立领域模型，这就是一个收敛的过程。

![DDD是如何进行战略设计.png](..%2Fimg%2F%E6%9E%B6%E6%9E%84%2FDDD%2FDDD%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%88%98%E7%95%A5%E8%AE%BE%E8%AE%A1.png)

我们可以用三步来划定领域模型和微服务的边界。

- 第一步：在事件风暴中梳理业务过程中的用户操作、事件以及外部依赖关系等，根据这些要素梳理出领域实体等领域对象。
- 第二步：根据领域实体之间的业务关联性，将业务紧密相关的实体进行组合形成聚合，同时确定聚合中的聚合根、值对象和实体。在这个图里，聚合之间的边界是第一层边界，它们在同一个微服务实例中运行，这个边界是逻辑边界，所以用虚线表示。
-

第三步：根据业务及语义边界等因素，将一个或者多个聚合划定在一个限界上下文内，形成领域模型。在这个图里，限界上下文之间的边界是第二层边界，这一层边界可能就是未来微服务的边界，不同限界上下文内的领域逻辑被隔离在不同的微服务实例中运行，物理上相互隔离，所以是物理边界，边界之间用实线来表示。

有了这两层边界，微服务的设计就不是什么难事了。

在战略设计中我们建立了领域模型，划定了业务领域的边界，建立了通用语言和限界上下文，确定了领域模型中各个领域对象的关系。到这儿，业务端领域模型的设计工作基本就完成了，这个过程同时也基本确定了应用端的微服务边界。

在从业务模型向微服务落地的过程中，也就是从战略设计向战术设计的实施过程中，我们会将领域模型中的领域对象与代码模型中的代码对象建立映射关系，将业务架构和系统架构进行绑定。当我们去响应业务变化调整业务架构和领域模型时，系统架构也会同时发生调整，并同步建立新的映射关系。

## DDD 与微服务的关系

有了上面的讲解，现在我们不妨再次总结下 DDD 与微服务的关系。

DDD 是一种架构设计方法，微服务是一种架构风格，两者从本质上都是为了追求高响应力，而从 业务视角
去分离应用系统建设复杂度的手段。两者都强调从业务出发，其核心要义是强调根据业务发展，合理划分领域边界，持续调整现有架构，优化现有代码，以保持架构和代码的生命力，也就是我们常说的演进式架构。

- DDD 主要关注：从业务领域视角划分领域边界，构建通用语言进行高效沟通，通过业务抽象，建立领域模型，维持业务和代码的逻辑一致性。
- 微服务主要关注：运行时的进程间通信、容错和故障隔离，实现去中心化数据管理和去中心化服务治理，关注微服务的独立开发、测试、构建和部署。

# DDD的一些术语

领域驱动设计（DDD）涉及许多特定的术语和概念，这些术语和概念有助于理解和实施领域驱动设计方法。以下是一些重要的DDD术语和概念：

1. 领域（Domain）：指特定问题领域或业务领域，包括相关的业务概念、规则和流程。在DDD中，设计的重点是深入理解和建模这个领域。
2. 领域模型（Domain Model）：领域模型是对业务领域中重要概念、实体、值对象、聚合以及它们之间关系的抽象表示。它是将业务逻辑和规则映射到软件设计中的核心。
3. 实体（Entity）：在领域模型中表示具有唯一标识的对象，它具有状态和行为。实体是领域模型中最常见的元素之一，例如，订单、用户等。
4. 值对象（Value Object）：在领域模型中表示没有唯一标识，仅由其属性值定义的对象。值对象通常用于描述领域中的属性，例如，日期范围、地址等。
5. 聚合（Aggregate）：一组相关实体和值对象的集合，由一个根实体（聚合根）管理其内部的一致性和完整性。聚合根是对外部的访问入口，保护了聚合内部的一致性。
6. 聚合根（Aggregate Root）：聚合中的一个实体，作为整个聚合的访问入口。所有对聚合内部的操作都应该通过聚合根进行。
7. 仓储（Repository）：用于管理领域对象的持久化和检索。仓储提供了一种抽象层，使应用程序可以从数据存储中获取和存储领域对象，而不必关心底层细节。
8. 领域事件（Domain Event）：表示在领域中发生的重要事件，它们可以被触发和发布，以便其他部分能够对事件做出响应。领域事件通常用于解耦和通信。
9. 限界上下文（Bounded Context）：指在领域模型中的一个明确定义的边界，限制了一组特定的业务概念和规则。不同的限界上下文可以有不同的术语和含义，但在各自的边界内是一致的。
10. 领域专家（Domain Expert）：是对特定领域非常了解的人，通常是业务领域中的专业人士，他们与开发团队合作，共同理解和建模业务。

![ddd总结图.png](..%2Fimg%2F%E6%9E%B6%E6%9E%84%2FDDD%2Fddd%E6%80%BB%E7%BB%93%E5%9B%BE.png)

这幅图总结的很全，他把DDD划分不同的层级，最里层是值、属性、唯一标识等，这个是最基本的数据单位，但不能直接使用。然后是实体，这个把基础的数据进行封装，可以直接使用，在代码中就是封装好的一个个实体对象。之后就是领域层，它按照业务划分为不同的领域，比如订单领域、商品领域、支付领域等。最后是应用服务，它对业务逻辑进行编排，也可以理解为业务层。

## 领域和子域

在研究和解决业务问题时，DDD 会按照一定的规则将业务领域进行细分，当领域细分到一定的程度后，DDD
会将问题范围限定在特定的边界内，在这个边界内建立领域模型，进而用代码实现该领域模型，解决相应的业务问题。简言之，DDD
的领域就是这个边界内要解决的业务问题域。

领域可以进一步划分为子领域。我们把划分出来的多个子领域称为子域，每个子域对应一个更小的问题域或更小的业务范围。

领域的核心思想就是将问题域逐级细分，来降低业务理解和系统实现的复杂度。通过领域细分，逐步缩小服务需要解决的问题域，构建合适的领域模型。
> 举个例子：
>
> 保险领域，我们可以把保险细分为承保、收付、再保以及理赔等子域，而承保子域还可以继续细分为投保、保全（寿险）、批改（财险）等子子域。

## 核心域、通用域和支撑域

子域可以根据重要程度和功能属性划分为如下：

- 核心域：决定产品和公司核心竞争力的子域，它是业务成功的主要因素和公司的核心竞争力。
- 通用域：没有太多个性化的诉求，同时被多个子域使用的通用功能的子域。
- 支撑域：但既不包含决定产品和公司核心竞争力的功能，也不包含通用功能的子域。

核心域、支撑域和通用域的主要目标是：通过领域划分，区分不同子域在公司内的不同功能属性和重要性，从而公司可对不同子域采取不同的资源投入和建设策略，其关注度也会不一样。

很多公司的业务，表面看上去相似，但商业模式和战略方向是存在很大差异的，因此公司的关注点会不一样，在划分核心域、通用域和支撑域时，其结果也会出现非常大的差异。

比如同样都是电商平台的淘宝、天猫、京东和苏宁易购，他们的商业模式是不同的。淘宝是 C2C 网站，个人卖家对个人买家，而天猫、京东和苏宁易购则是
B2C 网站，是公司卖家对个人买家。即便是苏宁易购与京东都是 B2C
的模式，苏宁易购是典型的传统线下卖场转型成为电商，京东则是直营加部分平台模式。因此，在公司建立领域模型时，我们就要结合公司战略重点和商业模式，重点关注核心域。

## 通用语言和限界上下文

- 通用语言：就是能够简单、清晰、准确描述业务涵义和规则的语言。
- 限界上下文：用来封装通用语言和领域对象，提供上下文环境，保证在领域之内的一些术语、业务相关对象等（通用语言）有一个确切的含义，没有二义性。

## 通用语言

通用语言是团队统一的语言，不管你在团队中承担什么角色，在同一个领域的软件生命周期里都使用统一的语言进行交流。那么，通用语言的价值也就很明了，它可以解决交流障碍这个问题，使领域专家和开发人员能够协同合作，从而确保业务需求的正确表达。

这个通用语言到场景落地，大家可能还很模糊，其实就是把领域对象、属性、代码模型对象等，通过代码和文字建立映射关系，可以通过Excel记录这个关系，这样研发可以通过代码知道这个含义，产品或者业务方可以通过文字知道这个含义，沟通起来就不会有歧义，说的简单一点，其实就是统一产品和研发的话术。

直接看下面这幅图：

![通用语言.png](..%2Fimg%2F%E6%9E%B6%E6%9E%84%2FDDD%2F%E9%80%9A%E7%94%A8%E8%AF%AD%E8%A8%80.png)

## 限界上下文

通用语言也有它的上下文环境，为了避免同样的概念或语义在不同的上下文环境中产生歧义，DDD 在战略设计上提出了“限界上下文”这个概念，用来确定语义所在的领域边界。

限界上下文是一个显式的语义和语境上的边界，领域模型便存在于边界之内。边界内，通用语言中的所有术语和词组都有特定的含义。把限界上下文拆解开看，限界就是领域的边界，而上下文则是语义环境。通过领域的限界上下文，我们就可以在统一的领域边界内用统一的语言进行交流。

## 实体和值对象

- 实体 = 唯一身份标识 + 可变性【状态 + 行为】
- 值对象 = 将一个值用对象的方式进行表述，来表达一个具体的固定不变的概念。

## 实体

DDD中要求实体是唯一的且可持续变化的。意思是说在实体的生命周期内，无论其如何变化，其仍旧是同一个实体。唯一性由唯一的身份标识来决定的。可变性也正反映了实体本身的状态和行为。实体以
DO（领域对象）的形式存在，每个实体对象都有唯一的 ID。我们可以对一个实体对象进行多次修改，修改后的数据和原来的数据可能会大不相同。但是，由于它们拥有相同的
ID，它们依然是同一个实体。比如商品是商品上下文的一个实体，通过唯一的商品 ID 来标识，不管这个商品的数据如何变化，商品的 ID
一直保持不变，它始终是同一个商品。

## 值对象

当你只关心某个对象的属性时，该对象便可作为一个值对象。 我们需要将值对象看成不变对象，不要给它任何身份标识，还应该尽量避免像实体对象一样的复杂性。

还是举个订单的例子，订单是一个实体，里面包含地址，这个地址可以只通过属性嵌入的方式形成的订单实体对象，也可以将地址通过json序列化一个string类型的数据，存到DB的一个字段中，那么这个Json串就是一个值对象，是不是很好理解？下面给个简单的图：

![值对象1.png](..%2Fimg%2F%E6%9E%B6%E6%9E%84%2FDDD%2F%E5%80%BC%E5%AF%B9%E8%B1%A11.png)

![值对象2.png](..%2Fimg%2F%E6%9E%B6%E6%9E%84%2FDDD%2F%E5%80%BC%E5%AF%B9%E8%B1%A12.png)

## 聚合和聚合根

### 聚合

聚合：我们把一些关联性极强、生命周期一致的实体、值对象放到一个聚合里。聚合是领域对象的显式分组，旨在支持领域模型的行为和不变性，同时充当一致性和事务性边界。

聚合有一个聚合根和上下文边界，这个边界根据业务单一职责和高内聚原则，定义了聚合内部应该包含哪些实体和值对象，而聚合之间的边界是松耦合的。按照这种方式设计出来的服务很自然就是“高内聚、低耦合”的。

聚合在 DDD 分层架构里属于领域层，领域层包含了多个聚合，共同实现核心业务逻辑。跨多个实体的业务逻辑通过领域服务来实现，跨多个聚合的业务逻辑通过应用服务来实现。比如有的业务场景需要同一个聚合的
A 和 B 两个实体来共同完成，我们就可以将这段业务逻辑用领域服务来实现；而有的业务逻辑需要聚合 C 和聚合 D
中的两个服务共同完成，这时你就可以用应用服务来组合这两个服务。

### 聚合根

如果把聚合比作组织，那聚合根就是这个组织的负责人。聚合根也称为根实体，它不仅是实体，还是聚合的管理者。

- 首先它作为实体本身，拥有实体的属性和业务行为，实现自身的业务逻辑。
- 其次它作为聚合的管理者，在聚合内部负责协调实体和值对象按照固定的业务规则协同完成共同的业务逻辑。
- 最后在聚合之间，它还是聚合对外的接口人，以聚合根 ID 关联的方式接受外部任务和请求，在上下文内实现聚合之间的业务协同。也就是说，聚合之间通过聚合根
  ID 关联引用，如果需要访问其它聚合的实体，就要先访问聚合根，再导航到聚合内部实体，外部对象不能直接访问聚合内实体。
  上面讲的还是有些抽象，下面看一个图就能很好理解：

![聚合.png](..%2Fimg%2F%E6%9E%B6%E6%9E%84%2FDDD%2F%E8%81%9A%E5%90%88.png)

简单概括一下：

- 通过事件风暴（我理解就是头脑风暴，不过我们一般都是先通过个人理解，然后再和相关核心同学进行沟通），得到实体和值对象；
- 将这些实体和值对象聚合为“投保聚合”和“客户聚合”，其中“投保单”和“客户”是两者的聚合根；
- 找出与聚合根“投保单”和“客户”关联的所有紧密依赖的实体和值对象；
- 在聚合内根据聚合根、实体和值对象的依赖关系，画出对象的引用和依赖模型。

## 领域服务和应用服务

### 领域服务

当一些逻辑不属于某个实体时，可以把这些逻辑单独拿出来放到领域服务中，理想的情况是没有领域服务，如果领域服务使用不恰当，慢慢又演化回了以前逻辑都在service层的局面。

可以使用领域服务的情况：

- 执行一个显著的业务操作
- 对领域对象进行转换
- 以多个领域对象作为输入参数进行计算，结果产生一个值对象

### 应用服务

应用层作为展现层与领域层的桥梁，是用来表达用例和用户故事的主要手段。

应用层通过应用服务接口来暴露系统的全部功能。在应用服务的实现中，它负责编排和转发，它将要实现的功能委托给一个或多个领域对象来实现，它本身只负责处理业务用例的执行顺序以及结果的拼装。通过这样一种方式，它隐藏了领域层的复杂性及其内部实现机制。

应用层相对来说是较“薄”的一层，除了定义应用服务之外，在该层我们可以进行安全认证，权限校验，持久化事务控制，或者向其他系统发生基于事件的消息通知，另外还可以用于创建邮件以发送给客户等。

## 领域事件

领域事件 = 事件发布 + 事件存储 + 事件分发 + 事件处理。

领域事件是一个领域模型中极其重要的部分，用来表示领域中发生的事件。忽略不相关的领域活动，同时明确领域专家要跟踪或希望被通知的事情，或与其他模型对象中的状态更改相关联，下面简单说明领域事件：

- 事件发布：构建一个事件，需要唯一标识，然后发布；
- 事件存储：发布事件前需要存储，因为接收后的事件也会存储，可用于重试或对账等；
- 事件分发：服务内直接发布给订阅者，服务外需要借助消息中间件，比如Kafka，RabbitMQ等；
- 事件处理：先将事件存储，然后再处理。

比如下订单后，给用户增长积分与赠送优惠券的需求。如果使用瀑布流的方式写代码。一个个逻辑调用，那么不同用户，赠送的东西不同，逻辑就会变得又臭又长。这里的比较好的方式是，用户下订单成功后，发布领域事件，积分聚合与优惠券聚合监听订单发布的领域事件进行处理。

## 资源库【仓储】

仓储介于领域模型和数据模型之间，主要用于聚合的持久化和检索。它隔离了领域模型和数据模型，以便我们关注于领域模型而不需要考虑如何进行持久化。

我们将暂时不使用的领域对象从内存中持久化存储到磁盘中。当日后需要再次使用这个领域对象时，根据 key
值到数据库查找到这条记录，然后将其恢复成领域对象，应用程序就可以继续使用它了，这就是领域对象持久化存储的设计思想。

# DDD分层架构

在领域驱动设计（DDD）中采用的是松散分层架构，层间关系不那么严格。每层都可能使用它下面所有层的服务，而不仅仅是下一层的服务。每层都可能是半透明的，这意味着有些服务只对上一层可见，而有些服务对上面的所有层都可见。

![DDD分层架构.png](..%2Fimg%2F%E6%9E%B6%E6%9E%84%2FDDD%2FDDD%E5%88%86%E5%B1%82%E6%9E%B6%E6%9E%84.png)

分层的作用，从上往下：

- 用户交互层：web请求，rpc请求，mq消息等外部输入均被视为外部输入的请求，可能修改到内部的业务数据。
-

业务应用层：与MVC中的service不同的不是，service中存储着大量业务逻辑。但在应用服务的实现中（以功能点为维度），它负责编排、转发、校验等。（在设计和开发时，不要将本该放在领域层的业务逻辑放到应用层中实现。因为庞大的应用层会使领域模型失焦，时间一长你的服务就会演化为传统的三层架构，业务逻辑会变得混乱。）
-
领域层：或称为模型层，系统的核心，负责表达业务概念，业务状态信息以及业务规则。即包含了该领域（问题域）所有复杂的业务知识抽象和规则定义。该层主要精力要放在领域对象分析上，可以从实体，值对象，聚合（聚合根），领域服务，领域事件，仓储，工厂等方面入手。

- 基础设施层：主要有2方面内容，一是为领域模型提供持久化机制，当软件需要持久化能力时候才需要进行规划；一是对其他层提供通用的技术支持能力，如消息通信，通用工具，配置等的实现。

应用服务层直接调用基础设施层的一条线，这条线是什么意思呢？领域模型的建立是为了控制对于数据的增删改的业务边界，至于数据查询，不同的报表，不同的页面需要展示的数据聚合不具备强业务领域，因此常见的会使用CQRS方式进行查询逻辑的处理。其它的直接调用，原理类同。

## 三层架构如何演进到 DDD 分层架构

![三层架构如何演进到DDD分层架构.png](..%2Fimg%2F%E6%9E%B6%E6%9E%84%2FDDD%2F%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84%E5%A6%82%E4%BD%95%E6%BC%94%E8%BF%9B%E5%88%B0DDD%E5%88%86%E5%B1%82%E6%9E%B6%E6%9E%84.png)

我们看一下上面这张图，分析一下从三层架构向 DDD 分层架构演进的过程。

首先，你要清楚，三层架构向 DDD 分层架构演进，主要发生在业务逻辑层和数据访问层。

DDD 分层架构在用户接口层引入了 DTO，给前端提供了更多的可使用数据和更高的展示灵活性。

DDD 分层架构对三层架构的业务逻辑层进行了更清晰的划分，改善了三层架构核心业务逻辑混乱，代码改动相互影响大的情况。DDD
分层架构将业务逻辑层的服务拆分到了应用层和领域层。应用层快速响应前端的变化，领域层实现领域模型的能力。

另外一个重要的变化发生在数据访问层和基础层之间。三层架构数据访问采用 DAO 方式；DDD
分层架构的数据库等基础资源访问，采用了仓储（Repository）设计模式，通过依赖倒置实现各层对基础资源的解耦。

仓储又分为两部分：仓储接口和仓储实现。仓储接口放在领域层中，仓储实现放在基础层。原来三层架构通用的第三方工具包、驱动、Common、Utility、Config
等通用的公共的资源类统一放到了基础层。

最后，我想说，传统三层架构向 DDD 分层架构的演进，体现的正是领域驱动设计思想的演进。希望你也感受到了，并尝试将其应用在自己的架构设计中。

当然不是所有的业务服务都合适做DDD架构，DDD合适产品化，可持续迭代，业务逻辑足够复杂的业务系统，中小规模的系统与团队还是不建议使用的，毕竟相比较与MVC架构，成本很大。

## 微服务要有合理的架构分层

微服务设计要有分层的设计思想，让各层各司其职，建立松耦合的层间关系。

不要把与领域无关的逻辑放在领域层实现，保证领域层的纯洁和领域逻辑的稳定，避免污染领域模型。也不要把领域模型的业务逻辑放在应用层，这样会导致应用层过于庞大，最终领域模型会失焦。如果实在无法避免，我们可以引入防腐层，进行新老系统的适配和转换，过渡期完成后，可以直接将防腐层代码抛弃。

微服务内部的分层方式我们已经清楚了，那微服务之间是否也有层次依赖关系呢？如何实现微服务之间的服务集成？

有的微服务可以与前端应用集成，一起完成特定的业务，这是项目级微服务。而有的则是某个职责单一的中台微服务，企业级的业务流程需要将多个这样的微服务组合起来才能完成，这是企业级中台微服务。两类微服务由于复杂度不一样，集成方式也会有差异。

## 项目级微服务

项目级微服务的内部遵循分层架构模型就可以了。领域模型的核心逻辑在领域层实现，服务的组合和编排在应用层实现，通过 API
网关为前台应用提供服务，实现前后端分离。但项目级的微服务可能会调用其它微服务，你看在下面这张图中，比如某个项目级微服务 B
调用认证微服务 A，完成登录和权限认证。

通常项目级微服务之间的集成，发生在微服务的应用层，由应用服务调用其它微服务发布在 API 网关上的应用服务。你看下图中微服务 B
中红色框内的应用服务 B，它除了可以组合和编排自己的领域服务外，还可以组合和编排外部微服务的应用服务。它只要将编排后的服务发布到
API 网关供前端调用，这样前端就可以直接访问自己的微服务了。

![项目级微服务.png](..%2Fimg%2F%E6%9E%B6%E6%9E%84%2FDDD%2F%E9%A1%B9%E7%9B%AE%E7%BA%A7%E5%BE%AE%E6%9C%8D%E5%8A%A1.png)

## 企业级中台微服务

企业级的业务流程往往是多个中台微服务一起协作完成的，那跨中台的微服务如何实现集成呢？

企业级中台微服务的集成不能像项目级微服务一样，在某一个微服务内完成跨微服务的服务组合和编排。

我们可以在中台微服务之上增加一层，你看下面这张图，增加的这一层就位于红色框内，它的主要职能就是处理跨中台微服务的服务组合和编排，以及微服务之间的协调，它还可以完成前端不同渠道应用的适配。如果再将它的业务范围扩大一些，我可以将它做成一个面向不同行业和渠道的服务平台。

我们不妨借用 BFF（服务于前端的后端，Backend for Frontends）这个词，暂且称它为 BFF 微服务。BFF
微服务与其它微服务存在较大的差异，就是它没有领域模型，因此这个微服务内也不会有领域层。BFF
微服务可以承担应用层和用户接口层的主要职能，完成各个中台微服务的服务组合和编排，可以适配不同前端和渠道的要求。

![企业级中台微服务.png](..%2Fimg%2F%E6%9E%B6%E6%9E%84%2FDDD%2F%E4%BC%81%E4%B8%9A%E7%BA%A7%E4%B8%AD%E5%8F%B0%E5%BE%AE%E6%9C%8D%E5%8A%A1.png)

## 应用和资源的解耦与适配

传统以数据为中心的设计模式，应用会对数据库、缓存、文件系统等基础资源产生严重依赖。

正是由于它们之间的这种强依赖的关系，我们一旦更换基础资源就会对应用产生很大的影响，因此需要为应用和资源解耦。

在微服务架构中，应用层、领域层和基础层解耦是通过仓储模式，采用依赖倒置的设计方法来实现的。在应用设计中，我们会同步考虑和基础资源的代码适配，那么一旦基础设施资源出现变更（比如换数据库），就可以屏蔽资源变更对业务代码的影响，切断业务逻辑对基础资源的依赖，最终降低资源变更对应用的影响。

## DDD、中台和微服务的协作模式

传统企业可以将需要共享的公共能力进行领域建模，建设可共享的 通用中台。除此之外，传统企业还会将核心能力进行领域建模，建设面向不同渠道的可复用的
核心中台。

而这里的通用中台和核心中台都属于我们上一讲讲到的业务中台的范畴。

DDD 的子域分为核心域、通用域和支撑域。划分这几个子域的主要目的是为了确定战略资源的投入，一般来说战略投入的重点是核心域，因此后面我们就可以暂时不严格区分支撑域和通用域了。

领域、中台以及微服务虽然属于不同层面的东西，但我们还是可以将他们分解对照，整理出来它们之间的关系。你看下面这张图，我是从 DDD
领域建模和中台建设这两个不同的视角对同一个企业的业务架构进行分析。

![ddd中台和微服务协作.png](..%2Fimg%2F%E6%9E%B6%E6%9E%84%2FDDD%2Fddd%E4%B8%AD%E5%8F%B0%E5%92%8C%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%8D%8F%E4%BD%9C.png)

如果将企业内整个业务域作为一个问题域的话，企业内的所有业务就是一个领域。在进行领域细分时，从 DDD
视角来看，子域可分为核心域、通用域和支撑域。从中台建设的视角来看，业务域细分后的业务中台，可分为核心中台和通用中台。

从领域功能属性和重要性对照来看，通用中台对应 DDD 的通用域和支撑域，核心中台对应 DDD
的核心域。从领域的功能范围来看，子域与中台是一致的。领域模型所在的限界上下文对应微服务。建立了这个映射关系，我们就可以用 DDD
来进行中台业务建模了。

我们这里还是以保险领域为例。 保险域的业务中台分为两类：第一类是提供保险核心业务能力的核心中台（比如营销、承保和理赔等业务）；第二类是支撑核心业务流程完成保险全流程的通用中台（比如订单、支付、客户和用户等）。

这里我要提醒你一下：根据 DDD 首先要建立通用语言的原则，在将 DDD 的方法引入中台设计时，我们要先建立中台和 DDD
的通用语言。这里的子域与中台是一致的，那我们就可以将子域统一为中台。

中台通过事件风暴可以进一步细分，最终完成业务领域建模。中台业务领域的功能不同，限界上下文的数量和大小就会不一样，领域模型也会不一样。

当完成业务建模后，我们就可以采用 DDD 战术设计，设计出聚合、实体、领域事件、领域服务以及应用服务等领域对象，再利用分层架构模型完成微服务的设计。

以上就是 DDD、中台和微服务在应用过程中的协作模式。

## 中台如何建模？

看完了三者的协作模式，我们就顺着上面的话题，接着来聊聊中台如何建模。

中台业务抽象的过程就是业务建模的过程，对应 DDD 的战略设计。系统抽象的过程就是微服务的建设过程，对应 DDD 的战术设计。下面我们就结合
DDD 领域建模的方法，讲一下中台业务建模的过程。

第一步：
按照业务流程（通常适用于核心域）或者功能属性、集合（通常适用于通用域或支撑域），将业务域细分为多个中台，再根据功能属性或重要性归类到核心中台或通用中台。核心中台设计时要考虑核心竞争力，通用中台要站在企业高度考虑共享和复用能力。

第二步： 选取中台，根据用例、业务场景或用户旅程完成事件风暴，找出实体、聚合和限界上下文。依次进行领域分解，建立领域模型。

由于不同中台独立建模，某些领域对象或功能可能会重复出现在其它领域模型中，也有可能本该是同一个聚合的领域对象或功能，却分散在其它的中台里，这样会导致领域模型不完整或者业务不内聚。这里先不要着急，这一步我们只需要初步确定主领域模型就可以了，在第三步中我们还会提炼并重组这些领域对象。

第三步： 以主领域模型为基础，扫描其它中台领域模型，检查并确定是否存在重复或者需要重组的领域对象、功能，提炼并重构主领域模型，完成最终的领域模型设计。

第四步： 选择其它主领域模型重复第三步，直到所有主领域模型完成比对和重构。

第五步： 基于领域模型完成微服务设计，完成系统落地。

![中台如何建模.png](..%2Fimg%2F%E6%9E%B6%E6%9E%84%2FDDD%2F%E4%B8%AD%E5%8F%B0%E5%A6%82%E4%BD%95%E5%BB%BA%E6%A8%A1.png)

结合上面这张图，你可以大致了解到 DDD 中台设计的过程。DDD 战略设计包括上述的第一步到第四步，主要为：业务域分解为中台，对中台归类，完成领域建模，建立中台业务模型。DDD
战术设计是第五步，领域模型映射为微服务，完成中台建设。

![中台如何建模2.png](..%2Fimg%2F%E6%9E%B6%E6%9E%84%2FDDD%2F%E4%B8%AD%E5%8F%B0%E5%A6%82%E4%BD%95%E5%BB%BA%E6%A8%A12.png)

那么如果还是以保险领域为例的话，完成领域建模后，里面的数据我们就可以填上了。这里我选取了通用中台的用户、客户和订单三个中台来做示例。客户中台提炼出了两个领域模型：客户信息和客户视图模型。用户中台提炼出了三个领域模型：用户管理、登录认证和权限模型。订单中台提炼出了订单模型。

这就是中台建模的全流程，当然看似简单的背后，若是遇上复杂的业务总会出现各种各样的问题，不然应用起来也不会有那么多的困难。

# COLA

https://www.youtube.com/watch?v=u6528XnMVFo

COLA 是 Clean Object-Oriented and Layered Architecture的缩写，代表“整洁面向对象分层架构”。 目前COLA已经发展到COLA v4

https://github.com/alibaba/COLA

COLA的架构

![cola架构.png](..%2Fimg%2F%E6%9E%B6%E6%9E%84%2FDDD%2Fcola%E6%9E%B6%E6%9E%84.png)

![cola架构2.png](..%2Fimg%2F%E6%9E%B6%E6%9E%84%2FDDD%2Fcola%E6%9E%B6%E6%9E%842.png)

其次，还有一个官方的表格，介绍了COLA中每个层的命名和含义：

| 层次	         | 包名	                 | 功能	                        | 必选 |
|-------------|---------------------|----------------------------|----|
| Adapter层	   | web                 | 	处理页面请求的Controller	        | 否  |
| Adapter层	   | wireless	           | 处理无线端的适配	                  | 否  |
| Adapter层	   | wap	                | 处理wap端的适配	                 | 否  |
| App层	       | executor	           | 处理request，包括command和query	 | 是  |
| App层	       | consumer	           | 处理外部message	               | 否  |
| App层	       | scheduler	          | 处理定时任务	                    | 否  |
| Domain层	    | model	              | 领域模型	                      | 否  |
| Domain层	    | ability	            | 领域能力，包括DomainService	      | 否  |
| Domain层	    | gateway	            | 领域网关，解耦利器	                 | 是  |
| Infra层	     | gatewayimpl	        | 网关实现	                      | 是  |
| Infra层	     | mapper	ibatis数据库映射	 | 否                          |
| Infra层	     | config	配置信息	        | 否                          |
| Client SDK	 | api	                | 服务对外透出的API	                | 是  |
| Client SDK	 | dto	                | 服务对外的DTO	                  | 是  |

这两张图和一个表格已经把整个COLA架构的绝大部分内容展现给了大家，但是一下子这么多信息量可能很难消化。

既然整个示例架构项目是一个Maven父子结构，那我们就从父模块一个个好好过一遍。

首先父模块的pom.xml包含了如下子模块：

```xml

<modules>
    <module>demo-web-client</module>
    <module>demo-web-adapter</module>
    <module>demo-web-app</module>
    <module>demo-web-domain</module>
    <module>demo-web-infrastructure</module>
    <module>start</module>
</modules>
```

## start层

该模块作为整个应用的启动模块（通常是一个SpringBoot应用），只承担启动项目和全局相关配置项的存放职责。代码目录如下：

![start层.png](..%2Fimg%2F%E6%9E%B6%E6%9E%84%2FDDD%2Fcola%2Fstart%E5%B1%82.png)

将启动独立出来，好处是清晰简洁，也能让新人一眼就看出如何运行项目，以及项目的一些基础依赖。

## adapter层

接下来我们按照之前架构图从上到下的顺序，一个个看。

首先是demo-web-adapter模块，这名字是不是很新鲜？但其实，可以理解为平时我们用的controller层（对于Web应用来说），换汤不换药。

在COLA官方博客中，也能找到如下的描述：

> Controller这个名字主要是来自于MVC，因为是MVC，所以自带了Web应用的烙印。然而，随着mobile的兴起，现在很少有应用仅仅只支持Web端，通常的标配是Web，Mobile，WAP三端都要支持。

![adapter层.png](..%2Fimg%2F%E6%9E%B6%E6%9E%84%2FDDD%2Fcola%2Fadapter%E5%B1%82.png)

## cilent层

有了我们说的“controller”层，接下来有的小伙伴肯定就会想，是不是service层啦。

是，也不是。

传统的Web应用中，完全可以只有一个service层给controller层调用，但是作为一个业务应用，除非你真的只是个前端页面的无情吐数据机器，否则很大可能性你的应用会有很多其他上下游调用方，并且你需要提供接口给他们。

这时候你给他们的不应该是一个Web接口，应该是RPC调用的服务层接口，至于原因不是本文的重点，具体就不展开了。

所以在COLA中，你的adapter层，调用了client层，client层中就是你服务接口的定义。

![client层.png](..%2Fimg%2F%E6%9E%B6%E6%9E%84%2FDDD%2Fcola%2Fclient%E5%B1%82.png)

从上图中可以看到，client包里有：

- api文件夹：存放服务接口定义
- dto文件夹：存放传输实体

注意，这里只是服务接口定义，而不是服务层的具体实现，所以在adapter层中，调用的其实是client层的接口：

```java

@RestController
public class CustomerController {

    @Autowiredprivate
    CustomerServiceI customerService;

    @GetMapping(value = "/customer")
    public MultiResponse<CustomerDTO> listCustomerByName(@RequestParam(required = false) String name) {
        CustomerListByNameQry customerListByNameQry = new CustomerListByNameQry();
        customerListByNameQry.setName(name);
        return customerService.listByName(customerListByNameQry);
    }

}
```

而最终接口的具体实现逻辑放到了app层。

```java

@Service
@CatchAndLog
public class CustomerServiceImpl implements CustomerServiceI {

    @Resource
    private CustomerListByNameQryExe customerListByNameQryExe;

    @Override
    public MultiResponse<CustomerDTO> listByName(CustomerListByNameQry customerListByNameQry) {
        return customerListByNameQryExe.execute(customerListByNameQry);
    }

}
```

## app层

接着上面说的，我们的app模块作为服务的实现，存放了各个业务的实现类，并且严格按照业务分包，这里划重点，是先按照业务分包，再按照功能分包的，为何要这么做，文章后面还会多说两句，先看图：

![app层.png](..%2Fimg%2F%E6%9E%B6%E6%9E%84%2FDDD%2Fcola%2Fapp%E5%B1%82.png)

customer和order分别对应了消费着和订单两个业务子领域。里面是COLA定义app层下面三种功能：

| a    | b         | c                         | d |
|------|-----------|---------------------------|---|
| App层 | executor  | 处理request，包括command和query | 是 |
| App层 | consumer  | 处理外部message               | 否 |
| App层 | scheduler | 处理定时任务                    | 否 |

可以看到，消息队列的消费者和定时任务，这类平时我们业务开发经常会遇到的场景，也放在app层。

## domain层

接下来便是domain，也就是领域层，先看一下领域层整体结构：

![domain层.png](..%2Fimg%2F%E6%9E%B6%E6%9E%84%2FDDD%2Fcola%2Fdomain%E5%B1%82.png)

可以看到，首先是按照不同的领域（customer和order）分包，里面则是三种主要的文件类型：

1. 领域实体：实体模型可以是充血模型（请自行了解），例如官方示例里的Customer.java如下：

```java

@Data
@Entitypublic
class Customer {

    private String customerId;
    private String memberId;
    private String globalId;
    private long registeredCapital;
    private String companyName;
    private SourceType sourceType;
    private CompanyType companyType;

    public Customer() {
    }

    public boolean isBigCompany() {
        return registeredCapital > 10000000; //注册资金大于1000万的是大企业
    }

    public boolean isSME() {
        return registeredCapital > 10000 && registeredCapital < 1000000; //注册资金大于10万小于100万的为中小企业
    }

    public void checkConfilict() {
        //Per different biz, the check policy could be different, if so, use ExtensionPointif("ConflictCompanyName".equals(this.companyName)){
        throw new BizException(this.companyName + " has already existed, you can not add it");
    }
}
}
```

1. 领域能力：domainservice文件夹下，是领域对外暴露的服务能力，如上图中的CreditChecker
2. 领域网关：gateway文件夹下的接口定义，这里的接口你可以粗略的理解成一种SPI，也就是交给infrastructure层去实现的接口。

例如CustomerGateway里定义了接口getByById，要求infrastructure的实现类必须定义如何通过消费者Id获取消费者实体信息，而infrastructure层可以实现任何数据源逻辑，比如，从MySQL获取，从Redis获取，还是从外部API获取等等。

```java
public interface CustomerGateway {
    public Customer getByById(String customerId);
}
```

在示例代码的CustomerGatewayImpl（位于infrastructure层）中，CustomerDO（数据库实体）经过MyBatis的查询，转换为了Customer领域实体，进行返回。完成了依赖倒置。

```java

@Componentpublic
class CustomerGatewayImpl implements CustomerGateway {
    @Autowiredprivate
    CustomerMapper customerMapper;

    public Customer getByById(String customerId) {
        CustomerDO customerDO = customerMapper.getById(customerId);
        //Convert to Customerreturn null;
    }
}
```

![domain层转换.png](..%2Fimg%2F%E6%9E%B6%E6%9E%84%2FDDD%2Fcola%2Fdomain%E5%B1%82%E8%BD%AC%E6%8D%A2.png)

## infrastructure层

最后是我们的infrastructure也就是基础设施层，这层有我们刚才提到的gatewayimpl网关实现，也有MyBatis的mapper等数据源的映射和config配置文件。

|        |              |              |
|--------|--------------|--------------|
| Infra层 | 	gatewayimpl | 	网关实现        |	是|
| Infra层 | 	mapper      | 	ibatis数据库映射 |	否|
| Infra层 | 	config      | 	配置信息        |	否|

![start层.png](..%2Fimg%2F%E6%9E%B6%E6%9E%84%2FDDD%2Fcola%2Fstart%E5%B1%82.png)


所有层讲完了，COLA4.0很简单明了，最后，在引用一段官方介绍博客原文来总结COLA的层级：

1）适配层（Adapter Layer）：负责对前端展示（web，wireless，wap）的路由和适配，对于传统B/S系统而言，adapter就相当于MVC中的controller；

2）应用层（Application Layer）：主要负责获取输入，组装上下文，参数校验，调用领域层做业务处理，如果需要的话，发送消息通知等。层次是开放的，应用层也可以绕过领域层，直接访问基础实施层；

3）领域层（Domain Layer）：主要是封装了核心业务逻辑，并通过领域服务（Domain Service）和领域对象（Domain Entity）的方法对App层提供业务实体和业务逻辑计算。领域是应用的核心，不依赖任何其他层次；

4）基础实施层（Infrastructure Layer）：主要负责技术细节问题的处理，比如数据库的CRUD、搜索引擎、文件系统、分布式服务的RPC等。此外，领域防腐的重任也落在这里，外部依赖需要通过gateway的转义处理，才能被上面的App层和Domain层使用。

## COLA架构的特色

说完了分层架构，我们再来回顾下上面提到的COLA架构的几个特色的设计
### 领域与功能的分包策略
也就是下面这张图的意思，先按照领域分包，再按照功能分包，这样做的其中一点好处是能将腐烂控制在该业务域内。

比如消费者customer和订单order两个领域是两个后端开发并行开发，两个人对于dto，util这些文件夹的命名习惯都不同，那么只会腐烂在各自的业务包下面，而不会将dto,util,config等文件夹放在一起，极容易引发文件冲突。

![领域与功能的分包策略.png](..%2Fimg%2F%E6%9E%B6%E6%9E%84%2FDDD%2Fcola%2F%E9%A2%86%E5%9F%9F%E4%B8%8E%E5%8A%9F%E8%83%BD%E7%9A%84%E5%88%86%E5%8C%85%E7%AD%96%E7%95%A5.png)

![领域与功能的分包策略2.png](..%2Fimg%2F%E6%9E%B6%E6%9E%84%2FDDD%2Fcola%2F%E9%A2%86%E5%9F%9F%E4%B8%8E%E5%8A%9F%E8%83%BD%E7%9A%84%E5%88%86%E5%8C%85%E7%AD%96%E7%95%A52.png)

> 前面的包定义，都是功能维度的定义。为了兼顾领域维度的内聚性，我们有必要对包结构进行一下微调，即顶层包结构应该是按照领域划分，让领域内聚。

### 业务域和外部依赖解耦

前面提到的domain和infrastructure层的依赖倒置，是一个非常有用的设计，进一步解耦了取数逻辑的实现。

例如下图中，你的领域实体是商品item，通过gateway接口，你的商品的数据源可以是数据库，也可以是外部的服务API。

如果是外部的商品服务，你经过API调用后，商品域吐出的是一个大而全的DTO（可能包含几十个字段），而在下单这个阶段，订单所需要的可能只是其中几个字段而已。你拿到了外部领域DTO，转为自己领域的Item，只留下标题价格库存等必要的数据字段。

![infrastructure层.png](..%2Fimg%2F%E6%9E%B6%E6%9E%84%2FDDD%2Fcola%2Finfrastructure%E5%B1%82.png)

# 链接

- https://tech.meituan.com/2017/12/22/ddd-in-practice.html
- https://github.com/alibaba/COLA
- https://www.cnblogs.com/rude3knife/p/cola-architecture.html
- https://blog.csdn.net/significantfrank/article/details/100074716
- https://www.youtube.com/watch?v=u6528XnMVFo
- https://www.youtube.com/watch?v=7kxZiJppcS0&list=PLn5XLkWHBxyt0jEp8DI_1gAsF6HsxKJRg&index=5
- https://zq99299.github.io/note-book2/ddd/#%E6%8E%A8%E8%8D%90%E9%98%85%E8%AF%BB
